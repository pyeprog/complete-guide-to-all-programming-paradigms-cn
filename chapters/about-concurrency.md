# 关于并发

为什么在模型尚处于初期阶段时, 就引入并发特性?   
难道其他特性不比并发更为基础吗?   
为何要如此执着于并发? 

## 为什么需要并发

谈及并发, 常强调其带来的性能提升, 比如并行计算如何利用多核CPU, IO多路复用如何提高吞吐量. 但如果我并不需要如此高的性能, 是否还需要并发?   

::::{grid} 2
:::{image} ../material/efficiency.jpeg
:::

:::{image} ../material/africa.jpg
:::
::::
我认为是需要的. 原因在于, 并发实质上带来了编程范式的变革, 而性能提升仅是其副产品. `现实生活中的万事万物本质上都是并发的`. 你不会等工作做完了才感到饥饿, 饥饿和完工的先后顺序是不确定的. \
`当我们采用并发编程范式时, 实际上更贴近现实系统的本质, 开发也因此更加便捷`. 

## 并发 > 并行

前文提及并发(concurrency)与并行(parallelism), 但实际上, **除了并行计算外, 我们较少讨论并行**. 因为并发体现了程序员的主观意图, 即声明希望任务并发执行. 这个意图与程序实现相关. 并行则是机器同时执行多个线程的行为, 是否并行取决于机器本身的配置, 与程序员无关. 因此, 我们更多关注并发. 无论是基于进程, 线程, 还是异步IO, 其核心意图都是“同时处理”, 因此统称为并发. 

## 并发中需要解决的问题

从还原论视角来看, 并发模型需处理线程的创建, 管理及线程间数据交换问题. 换一个更具目的论的视角, 主要需解决两类问题: 

1. `竞争问题(compete)`: 如何在多个线程同时执行时, 保证同一组数据不被竞争性读写而破坏.   
2. `协同问题(coordinate)`: 如何通过多线程协同加速数据流动, 或者更直接地说, 如何构建高效的数据流. 

:::{image} ../material/concurrency-problem.png
:width: 100%
:align: center
:::
