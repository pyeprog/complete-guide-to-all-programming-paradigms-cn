# Modular Model & Modular Programming

![[Think 2025-06-22 22.22.50.excalidraw]]
modular model是一个公认的好模型, 它几乎算是工程标配. 除了古早的语言和极少数现代语言之外(c/c++), 几乎所有的语言都支持modular programming. 有些语言甚至强制按module组织项目.

## Modular Model带来的新特性

这个模型增加两个新特性.
首先它定义了module的概念. module是一个容器, 我们可以把相关的一组常量, 函数, 类型定义(包括struct和enum), 以及后面会提到的类放在同一个容器之中, 在取用的时候需要在前面指定“module名字.”, 代表你调用的是module中的内容. 如此一来, 所有常量, 函数, 类型和类等元素都有了归属, 不再存在同名函数冲突的问题. (当然如果module名字冲突仍然存在). 另外, 所有的大模块内部也可以继续拆分成若干小模块, 如此层层拆分形成模块树, 最终叶子模块只承载必要的一小部份元素, 变得短小精干.

另一个特性是元素会被指定是否对外部可见. 绝大部份语言都提供约束可见性的关键词, 譬如标记可见的public / export / pub, 或者标记不可见(私有)的private, defp等等. 有些语言不支持强硬的可见性约束, 但在这些语言的编程惯例中使用特殊命名来表明是否私有, 譬如python中函数名以下划线开头代表私有, 不推荐外部引用.

这两个特性看起来简单, 实则效用巨大.
![[Think 2025-06-17 14.56.32.excalidraw]]

## Modular Model能够约束系统复杂度

modular programming是约束系统复杂度的必要手段.
首先系统职责被切分给来若干个子模块, 小模块更简单, 更容易被实现, 也更容易复用. 另外, 我们隐藏大部份的元素, 只暴露少量的类型, 函数, 类等元素给外界, 这本质上定义了模块的接口. 其他模块只能调用这些接口元素, 这让模块之间的交互变得简单. 修改代码时, 只要接口不变, 修改模块中的代码, 外界不会有任何感知.

通过使用modular model, 我们可以尽可能减少系统的整体复杂度. 系统的整体复杂度是互相交互的每个模块复杂度的乘积, 而每个模块的复杂度是其接口的复杂度. 模块之间交互的接口越简洁, 系统整体复杂度越低.
既然如此, 我把整个系统写成一个大模块, 没有模块之间的交互, 岂不是复杂度最低?
并不是, 同时混合了多个职责的模块, 其实内部暗含了好几个子模块, 如果不用模块去约束他们, 就相当于他们暴露了自己全部的元素, 这样的复杂度反而高.
![[Think 2025-06-07 11.54.13.excalidraw]]

在不同的语言中, module的叫法有所不同, 有些语言称为module(有些简写成mod), 另一些语言中称为package(譬如java). 不同语言中定义module的方式也有所不同.

## 不同语言中定义模块的风格对比

定义模块和引用模块是语言中非常重要的一环, 他和编译器或解释器如何寻找源文件, 如何组织编译成品(object, bytecode等等), 如何解析对模块的引用息息相关.
![[Think 2025-07-16 19.56.46.excalidraw]]

一般而言, 有两种风格区别. 隐式定义和显示定义. 我们一一介绍.

### 隐式风格

隐式定义会把每个源文件作为一个module, 譬如`user.rs`, 就对应user这个module. `drawer/mod.rs`是一个特殊的文件, 对应drawer这个module. 在这种风格之下, 很多语言都还支持在单个文件中定义sub module. 譬如在rust中, 有个文件`a.rs`, 其中有`mod sub`, 我们就是在a中定义了sub这个子模块.
这种风格之下, 源文件怎么组织, module就怎么定义. 是最直观最好理解的风格.
使用的时候通过类似于`import a.b`这样的语句, 编译器或解释器就会去寻找`a/b.xx`或`a/b/mod.xx`的源文件.

### 显示风格

显示定义需要在源文件中指定module的定义. module结构和文件结构并没有直接的关系. 你可以在6个源文件中定义3个module, 或者反过来3个源文件定义6个module. 这里module是逻辑上的module, 跟文件和文件结构都没有关系. 这是个大前提. 所以你想怎么组织module和怎么组织代码结构, 两者并不一定一一对应, 就算不对应, 也能够正确编译或执行. 不过基本所有语言代码范式都要求, 两者最好一一对应.

显示定义有两种风格, wrapper和tag.
wrapper会定义一个代码块, 然后把内容包在里面. tag会在源文件开头打上`package <name>`表明该源文件属于哪个module.
无论是哪种风格, module只存在于编译后的可执行文件或字节码中, 而跟代码没有一一对应关系. 使用的时候通过`import a.b`这样的语句, 编译器或解释器会从编译后的可执行文件或字节码中找到相应的module.

### 构建大型项目

为什么要提及模块定义这件小事呢? 因为它和项目构建息息相关.
你会发现有些大型项目构建很麻烦, 需要复杂的构建工具, 还要写很多相关配置文件, 譬如说java系的maven, gradle, scala中的sbt, elixir中的mix等等.
而另一些大型项目构建就很容易, 基本就是原生编译器或解释器一句简单的命令搞定, 譬如很多脚本语言只需要执行入口文件即可.

通常构建项目简单的都是隐式风格的语言, 而麻烦的基本是显示风格. 为什么? 因为构建项目首先需要寻找源文件.
隐式风格源文件和模块息息相关. 我们只需要解析入口文件引用了什么模块, 就能够去找到对应的源文件, 然后在这些原文件中重复刚才的过程, 依此类推就能找到所有的源文件.

而显示定义中编译器或解释器并不知道怎么找到源文件. 所以一般需要手动给定一堆源文件, 或者直接用工具把整个路径下所有的源文件全部扒出来, 至于你怎么组织这些文件, 是怎样的嵌套文件夹, 都没有关系, 结果都一样. 编译器在编译完毕后会按照module的定义去组织字节码文件. 这就是为什么这些语言中构建大型项目一般要搭配一个构建工具, 因为手动操作这些步骤很繁琐.

不过一些显示定义风格的语言采用了另一种巧妙的方法, 在引用模块的时候, 不去`import a.b`而是直接`import "file.path"`, 直接指定模块的源文件路径. 这样一来, 编译器又可以自动解析所有的源文件了. go就是这么做的. 所以编译go mod变得非常简单.

### 怎么快速上手

想要快速上手, 我们需要了解以下几个要点.
首先, 通过语法, 你能够快速的了解当前的语言支持的是哪种风格的定义. 如果是显示风格的, 那么可以直接搜索语言+toolchain, 或者语言+build tool. 了解如何使用build tool创建项目和构建项目.

其次, 无论何种风格, 每个项目都会有项目根目录, 显示风格中的build tool会根据从根目录下的某个子目录去搜索源文件. 隐式风格的编译器或者解释器会把入口文件路径默认为根目录, 它会从根目录去寻找对应模块的源文件. 所以在一些特定的情况下, 可能会导致错误, 在这个例子中, 如果我想直接调用deeply.nested.test, 解释器会以deeply.nested作为根目录, 这样一来test中的import会导致找不到module的错误.

最后, 无论什么风格, 最佳实践都是让代码结构和module结构一一对应. 隐式风格强制这一点, 而采纳显示风格的语言则通过范式要求这一点, 而且几乎没有例外.

### 例外

除开古早的语言和冷门的语言, 也有少部份语言目前是不支持module的, 譬如c/c++(c++这个特性未来会有). 另外有一些语言定义了一种完全不同的module体系, 譬如swift, 这里也就不再展开了.

### legacy

ref: [[module syntax in bunch of languages]]
一般而言有两种定义方式, 隐式定义和显示定义.
![[Think 2025-06-17 16.28.58.excalidraw]]
在确定项目的root_path的前提下,

- 隐式定义会把每个源文件当作一个module, 部分语言也支持把文件夹当作module, 只不过需要一点额外的配置或代码, 而文件夹中的源文件则是其子模块. 这种风格下文件和module是一一对应的, 文件组织结构和module的组织结构也是一一对应的, 比较好理解. 编译器或解释器会按照module的组织结构去寻找相应的源文件.
- 显示定义有两种风格, 一种是wrapper风格, 一种是tag风格.
 	- wrapper风格使用mod / namespace / defmodule等关键词创建一个scope, 然后把相关的函数, 类, 常量的定义放入其中.
 	- tag风格一般使用package关键词, 在源文件开始处指定当前文件内容属于哪一个package.

虽然一般支持显示定义module的语言, 都支持module名和文件路径名无关. 但这些语言几乎都有一个惯例是module的命名和文件路径挂钩.
部分语言同时支持显式和隐式定义.

在引用这些module的时候, 一般都是使用module的绝对路径(或全名), 在少量隐式定义的语言中, 也支持module的相对路径.

不同的module风格, 构建/编译/运行大型项目的难度也不同.

- 隐式定义因为把源文件当做module, module的层级结构完全对应文件结构. 所以采用这样风格的语言, 一般只需要编译或运行入口文件即可. 在解析到其引用的其他module之后, 再去对应路径寻找相应的源文件即可. 这相对而言比较简单.
- 而显式定义, module结构和文件结构脱开, 所以他们的编译或执行需要指定module结构和文件结构的对应方式, 目前总结有以下几种.
 	- 第一种, 引用其他module时, 完全放弃module结构, 直接引用具体文件. go, javascript, lua, lisp等语言采用这种机制. 这带来另一个问题, 第三方package怎么引用呢? 通常, package manager会安装package到指定位置, 我们在使用时只需要当做三方package在项目根目录下即可. 这种机制下, 编译时只需要指定入口文件即可.
 	- 第二种, 强制要求module结构和文件结构一一对应. elixir采用这种机制. 这种机制等于退回隐式定义, 并且徒增了冗余定义, 所以一般很少见.
 	- 第三种, 在编译器之上, 引入build tool. 一般build tool有很强的规范, 规定项目结构必须是什么样子, 源文件必须放在哪里, 必要时还需要编写配置文件. c, c++使用make或cmake, java中使用maven或gradle, scala中使用sbt, rust中使用cargo, 他们均采用这种机制. 这种机制下, 编译使用build tool, 由它来解析引用, 寻找文件, 匹配文件和module结构.

除开古早的语言和冷门的语言, 也有少部份语言目前是不支持module的, 譬如c/c++(c++这个特性未来会有). 另外有一些语言定义了一种完全不同的module体系, 譬如swift, 这里也就不再展开了.

## Module和object的关系

为什么modular model会和object扯上关系? 我们仔细观察代码式如何使用module的. 我们会发现, module和object在使用上的唯一区别是, module是个单例对象, 而且其中一般没有状态变量, 除此之外module能够进行封装, 并对外提供自己定义的接口. module提供了object功能的子集.
![[Think 2025-06-17 17.10.17.excalidraw]]

## 如何用好module

什么时候使用module呢? 如果没有特殊要求, 最好处处使用, 一直使用,.

一般简单的feature用起来门道多, 复杂的feature则正相反. modular model很简单, 只不过是把同类的函数放在一起, 提升内聚, 对外提供定义好的接口, 降低系统复杂度. 但如何用好module是一门学问.

### Group by Feature VS Group by Subject

首先, 如何整理模块? 把相关的元素整理到模块里, 方法有很多, 最常见的有两种方式. 一种叫"group by subject", 一种叫“group by feature".
以web server项目为例, 按照java中的命名方式, 一般有model, service, controller这几类对象. model是负责承载数据的类, service负责提供业务逻辑的类, controller负责注册url以及处理请求的具体逻辑.
如果服务有两个api, 一共提供User的增删改查, 一个提供Product的增删改查.
group by subject就是把User和Product的model放在一个模块中, 两者的service放在一个模块中, 两者的controller放在一个模块中, 所有的util/helper放在一个模块中.
而group by feature则按照不同的feature来组织, User相关的所有内容放在User模块, 其中有User相关的model, service, controller, util, 分别放在相应的子模块. 同理Product.
![[Think 2025-06-17 17.25.08.excalidraw]]

group by subject适合简单人少的项目, 因为在这种项目中工作并不需要对feature有理解, 也不需要费力去组织模块.
但是当项目逐渐变大, 人员逐渐变多, group by subject的劣势就非常明显了. 首先model, service, controller等模块混杂了所有业务的代码, 所以这些模块不可能被复用. 第二, 所有业务的service类都放在一起, 难免有人会禁不住诱惑在自己的service中调用别的service, 把本该独立的service耦合起来, 后续要改就非常困难了. 第三, 所有人都需要修改所有模块, 很难分配代码的归属权和责任范围, 这对大团队合作非常不利.

group by feature是业界比较推荐的代码组织方式, 适合长期, 大规模的项目. 但业务在演进, feature本身也在不断改变. 模块组织需要对应业务本身的演进. 所以在业务发生改变的时候, 需要及时重构, 调整模块组织. 否则就会欠下技术债.

### 如何评价模块质量

其次, 如何评价模块的质量?
首先, 评价模块的interface的质量

- 是否履行单一职责, 处理同一类或者同一个范畴的问题? 如果不符合单一职责, 模块组织就不算合格.
- api设计是否简洁有扩展性? 函数不应该设计的过于具体, 否则api中会有多个非常类似的api, 这不够简洁. 函数不应该设计的过于抽象, 过于抽象就能够承载多于一个职责, 使用起来也困难. ![[Think 2025-06-22 23.20.11.excalidraw]]
- api中每个函数是否有足够的doc说明其用途? 这里doc不应该说明函数的实现细节, 而应该说明函数的意图和行为.

其次, 评价模块的独立性. 我们把独立性分为几档.

- 拥有最佳独立性的模块, 只依赖内部子模块和三方模块, 不依赖其他模块. 这样的模块甚至可以独立发布. 一般业务无关的通用的util会整理成这种模块. 有必要的话model也可以整理成这样的模块进行内部发布.
- 如果一个模块还依赖自己的兄弟模块, 独立性就弱一些, 但在其父模块中, 他仍然保持了一定的灵活性.
- 如果一个模块反过来依赖了父模块, 抑或其他同级或更高的模块, 那就在模块依赖树中引入了环. 环涉及到的模块会全部耦合在一起. 一般出现这种情况是对代码库的巨大破坏.
![[Think 2025-06-08 14.42.03.excalidraw]]

### 两种常见情况的处理

下面再说两个常见的状况.
第一个状况. 有时我们会发现在实现自己模块的时候, 其他模块有一些私有的util特别方便, 想要拿来主义, 应该怎么做呢? 有两种办法.
我们可以把这个私有的util提到更高的module下面. 这样对方module和我的module就能引用这个util了. 不过, 首先util要适合暴露出来, 比较通用, 没有副作用才可以. 因为一旦提出来, 别人也会引用, 绝对不可能再放回去.
另一种做法是, 直接复制一份util到自己模块下面. 有人会反对, 说这样增加了代码的冗余程度, 这并不假, 但比起代码冗余度而言, 模块性更加重要. 但两份util需要被两个团队维护, 并且这两个团队没有共同演化愿景的时候, 这么做就是合适的. 当然, 这种情况发生不会特别频繁. 如果你发现有大量的内容需要搬到自己的模块下面, 应该想一想自己模块是否有存在的必要.
![[Think 2025-06-08 15.21.24.excalidraw]]

第二个状况. 有时候我们会发现一些三方模块或库我们需要重度使用, 这些三方模块或库如此之重要, 以至于几乎每一个模块我们都需要依赖它们, 譬如一些特殊的计算模块, 特殊领域的概念和util, 或者数据库等常用的功能.
在引入它们之前需要做一个抉择, 引入后是直接使用它们, 还是重新封装一套相同api的模块, 并将功能代理给它们?
![[Think 2025-06-08 15.39.58.excalidraw]]
如果引入的库, api / 性能是绝对稳定的, 我们的需求也是绝对稳定的, 不需要在三方库的基础上进行扩展, 那么直接使用它们是合理的.
但, 如果这些库api仍旧在发生变化, 性能并不稳定, 甚至还有一些corner case并不适合我们的需求, 我们也仍然存在扩展这些api的需求, 那么就推荐封装自己的module, 提供一套一模一样的api, 并代理给三方库. 这样任何改动, 甚至是切换底层的三方库, 我们都只需要修改自己的module. 而其他的调用的代码都不需要改动. 这是应用依赖反转原则的一种实际场景
