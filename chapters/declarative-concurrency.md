# Declarative Concurrency

![[Think 2025-06-22 15.02.20.excalidraw]]

接下来, 我们引入并发的概念, 并逐步进入面向并发编程. 来聊聊declarative concurrency.

## 新增的特性

首先我们在本就非常瘦的declarative model上引入线程的概念.
启动任意一个程序, 操作系统都会创建一个进程来维护程序运行上下文, 每一个进程就像一个独立的工厂, 内存空间是彼此独立的, 要协同工作比较困难. 而线程就像工厂中的一个个车间, 它们独立运行, 但又能够访问共同的一块内存空间, 因此协作起来比较方便. 而且创建并维护线程的开销比进程要小的多, 因此线程是更为流行的并发机制.

但我们从顺序执行模型(sequential model)转换到并发模型(concurrency model), 实际上引入了好几个问题
![[Think 2025-06-15 15.28.32.excalidraw]]

- 首先怎么创建线程, 确保它能够工作?
- 其次, 我怎么才能拿到它的工作成果? 这其中还要解答什么时候拿, 以及怎么拿的两个子问题.
- 最后, 我能在一个线程里停止另一个线程吗? 这涉及到线程的管理.

concurrent declarative model引入了thread的概念, 实际上只解决了创建线程的问题. 但并不解决线程协同和管理的问题. 我们需要后续更强而有力的模型来解决.

## 创建线程

说到创建线程. 在所有语言中, 最主流的创建线程方式是以函数作为入口启动线程. 绝大部分常见语言都是如此. 这样做有诸多好处, 譬如上下文管理简单, 结构清晰等等.
![[Think 2025-06-15 15.33.13.excalidraw]]
少部份语言支持一种更为自然的创建线程方式——把代码块, 甚至表达式作为线程主体. 这样的好处是代码更自然, 但自然的代价是, 它需要更多其他的概念来支持其正确运行. 譬如如果以表达式作为主体启动线程. 其他线程在需要该表达式求值的时候, 自动的等待表达式线程结束并得到他的值. 这种机制不太普遍. OZ这种语言支持如此创建线程, 但它需要一种叫做dataflow variable的机制来在线程之间获取计算结果. 但这并不主流. 主流依然是以函数作为主体创建线程.

## 什么时候使用这种简易的并发模型?

如果我只创建一堆线程, 却不支持他们互相协作, 甚至不让其知道彼此的存在, 这样的并发有用吗? 用处有限. 因为我只能启动线程, 线程独立处理任务, 然后和系统进行IO交互, 而且即使完成任务, 整个程序也永远不能正常退出. 总之, 在thread之上, 我们还需要更多机制才能真正解决一些并发任务.

## 系统级线程 Vs 轻量级线程

虽然concurrent declarative model很瘦, 仅仅提供thread, 但thread的不同设计实现也是很重要的一环. 同一台机器上, 能够顺畅开启十万线程相比只能启动几千个线程有着本质差别. 要进入面向并发编程, 能开更多线程自然能力更强.
很多语言提供的线程实际上是系统级线程, 创建这样的线程需要做系统调用, 线程也受操作系统调度, 好处是这样简单, 坏处是其能力上限基本跟操作系统挂钩.
而一般为了面向并发编程设计的语言会提供诸如green-thread, goroutine这样的轻量级“线程”. 所谓轻量级”线程“实际只是概念上的线程, 底层仍旧需要系统线程进行切实的执行. 但轻量级线程调度由语言的runtime自己控制, 执行总体效率也更高, 创建开销更小. 更重要的是, 在使用上系统线程和轻量级线程并无任何区别. 相当于白赚.
