# Concurrency Oriented Programming

![[Think 2025-06-22 15.37.14.excalidraw]]

## 面向并发编程的优点

从message-passing之后, 我们逐渐进入面向并发编程的世界里.
面向并发编程实际上是一种新的编程范式, 它天然可以用来模拟并发的世界模型, 并且还拥有诸多强大的性质, 包括

- 可扩展性, 只需要增加线程数量, 就能达到扩展系统的目的.
- 较高性能, 能够充分利用系统资源
- 高响应, 因为有海量线程, 因此每个请求到达几乎都有空闲的线程可以立即处理.
- 健壮性, 一个线程崩溃, 并不会影响整个系统
这是面向并发编程的优点.

## 面向并发编程的范式

面向并发编程和普通的编程范式有一定区别. 这里简述一下.

如果你做过web开发, 我们可以回想一下, 一个普通的server能够做什么. 一个普通的server无论使用哪种protocol, 总会有一组api, 其他进程可以对其发送请求, 并得到相应的应答. server可以用来执行某种计算任务, 可以类比为运行在其他进程中的函数; 一旦server有存储能力, 我们还可以向它读写数据, 可以类比为声明在其他进程中的数据容器.

面向并发编程, 就是在一个系统进程中启动若干线程, 这些线程可以被当成计算单元使用, 或者可以被当作数据容器使用. 线程之间可以进行通信. 其他线程可以发送消息去使用这些服务的线程提供的能力, 也可以接受这些服务线程发送的消息以获得返回值. 代码类似于下面这样.
![[Think 2025-06-01 20.20.12.excalidraw]]

补充说明, 所谓消息, 一般而言只是一个named tuple, 写作`Name(field1, field2, ..)`. 底层只是一段数据`(Name, field1, field2, ..)`, 而这个named tuple可以通过channel传递, 可以通过message传递, 当然还可以通过共享内存传递.
原来我们创建一个数据容器去承载数据, 现在我们启动一个service线程, 对其发送消息去进行读或写, 原来我们调用函数进行计算, 现在我们启动一个service线程, 对其发送去请求计算, 并接受其发回来的应答作为结果.

但, 如果我就写个a+b, 有必要启动一个线程, 然后发送请求吗? 这里面向并发编程并不是说纯粹并发, 只用并发. 它的表达式和函数调用跟其他模型也没有区别. 至于选择本地调用还是服务+消息, 全看需求.

什么时候选择启动线程, 而不是简单的调用函数呢?

- 如果需要管理一下长期存在的状态时, 譬如我想要管理从系统启动以来的qps的数据
- 如果需要管理一些需要被复用的资源, 譬如数据库连接, TCP连接, 或者文件句柄等等
- 如果有一段代码使用到了某些资源需要被互斥的运行, 我们可以把这段代码放到service线程中. 如此以来, 我并不需要对代码段加锁, 而是对线程发请求.
- 需要承接大量IO请求的时候, 对每个请求启动一次性的用完即关闭的线程. 这样效率比较高.
以上就是在面向并发编程的范式下, 选择线程而不是简单调用的场景.

上述面向并发编程可能会让你想到微服务, 至少看起来有几分神似. 面向并发编程是语言范畴的概念, 而微服务是应用架构范畴的概念, 虽然两者在不同领域, 但却有很多十分类似的实践. 了解面向并发编程, 能让你更好的了解微服务的实践, 你甚至能在其中看到一些云原生应用中的对应概念.

## Actor Model

虽然我们可以开启海量线程(goroutine)来协同工作, 但在CSP模型中代码写起来还是非常冗长繁复. 究其原因, CSP模型抽象了线程间交换数据, 让这一部份代码变得很简单, 但是线程的启动, 管理, 以及指定数据流向(创建channel并塞给各个goroutine), 我们都还需要手动操作, 大部份的冗长代码都在完成这些工作.

最早由Carl Hewitt提出了actor model, 该模型就是要进一步抽象线程管理, 数据流向, 使得整个语言更适合面向并发编程. actor model并不是和语言强绑定的model, 很多语言都有自己的actor model的实现.

### Actor model和CSP Model的不同之处

![[Think 2025-05-31 11.40.46.excalidraw]]
actor model和CSP model有什么不同呢?
首先, 我们不再显式的创建channel, 取而代之, 每个线程启动后都会创建一个专有队列, 专门接收发往本线程的消息. 每个线程创建之后会返回一个线程id, 在面向并发编程的传统里, 我们称为process id, 简称pid. 其他线程只需要向这个pid发送消息即可. 我们不需要像CSP model中一样, 手动传递channel, 然后通过channel来收发数据, 而是`send(pid, {:name, field1, field2, ...})`像这样发送消息.

在线程中收信息时, 我们也不用select+channel, 而是使用receive关键词, 直接从专有队列中抽取消息, 进行模式匹配. 匹配上的消息则进行相应处理.
![[Think 2025-05-31 11.57.33.excalidraw]]
这里是一个elixir的例子. 可以看到其启动线程, 收发消息代码.  孵化Talker线程之后, 我们会得到其pid, 我们通过向pid发送消息来触发Talker中相应代码. Talker调用loop方法并进行递归, 这等同于循环执行loop方法. receive会在消息队列为空时挂起线程, 等有消息时恢复. 类似于CSP model中的select.

另外我们可以link两个线程, 如果其中一个崩溃退出, 另一个会收到exit信号, 我们可以在收到exit信号的时候进行线程操作, 譬如重启, 这种机制让线程之间的管理变得方便, 因为我们不再需要手动构造心跳机制了. 这个例子中, 我们通过spawn_link创造一个跟当前线程link在一起的线程. 我们也可以使用OTP库中的GenServer和Supervisor module来创建link在一起的线程.
![[Think 2025-06-15 21.45.21.excalidraw]]

 actor model提出了一种很强的范式, 会极大影响代码组织结构, 相比于低层的CSP模型和共享内存模型, 它更高级, 而代价则是, 更不通用. 所以相比于其他通用的范式, 它主要被用来做并发问题的建模.

### Actor Model中的特定写法

#### How to get the result

actor model的整体崇尚fire and forget的风格, 即启动一个线程去完成特定任务, 但线程一旦创建就不再管理, 也不会去期待返回值, 又或者对于一个已经存在的service线程发送消息, 消息一旦发送就不再管理, 也无法得到对方处理消息之后的应答. 那当我需要这些任务的返回值时应该怎么办呢? 我们能不能像调用一个函数那样, 调用完毕就拿到其返回值呢?

此处需要实现一种synchronize机制, 采用spawn + receive 或者 send + receive的方式. 先启动任务或发送消息, 在任务参数或者消息体中放入自己线程的pid, 然后立即receive等待接收对方发过来的response消息. 这种写法是actor model的特色, 我们来看看具体写法.
![[Think 2025-06-15 21.58.38.excalidraw]]
这种写法会带来一个问题, 如果你一次性发送若干个请求, 其应答消息并不一定会按照顺序收到. 这带来了一些限制.

#### How to jump out of nested recursion

出于某种原因, 原生支持actor model的语言, erlang / elixir底层都是declarative model, 因此这两门语言中都没有循环, 都需要使用递归, 一些复杂的递归会层层嵌套. 如果我需要从嵌套很深的地方退出递归怎么做呢? 我们可以使用throw, 抛出一个“异常”, 然后外层catch住, 以此来退出嵌套递归.

### 什么时候使用actor Model

使用actor model的前提是需求本质上是处理并发的问题, 需求一定要涉及到多个主体同时运行, 并实时交互.
如果需求是同质的线程对有限资源的竞争利用, 那actor model就不太合适, 它不会用于对数据进行大规模的批处理(batch data processing).
actor model更多强调不同的主体独立运行, 通过异步消息, 彼此沟通, 以此编织计算逻辑. 它更强调大规模异步业务逻辑执行, 而不是大规模同步数据处理.

所以, 它有以下几个应用场景

- server side system, 最经典的莫过于web server
- 分布式系统, 尤其是任务有很强时效性的分布式系统, 譬如模拟电梯调度, 模拟电路系统等等.

### 怎么使用actor Model?

所以使用actor model有什么特定的pattern或者特定的应用呢?

#### Stateful Service中的pattern: 有限状态机

首先是有限状态机(Finite State Machine).
简单的service可以是无状态的. 而复杂的service可以拥有状态. 每个有状态的service都是一个有限状态机. 根据自身当前的状态, 以及收到的消息, 来判定当下应该执行什么逻辑, 以及更新到什么状态. 代码以这种形式展现是因为语言中没有循环, 所以要以尾递归的方式实现循环. 而状态作为每一次递归的参数存在. 这种写法几乎渗透在任何service中.
![[Think 2025-06-15 22.06.18.excalidraw]]

#### Supervisor Tree

回顾上面CSP model中, 会有一些线程是supervisor. 在actor model中也有一些supervisor线程负责管理其他线程, 当worker线程出错退出, supervisor线程会收到消息, 并负责重启worker线程. actor model提供了link机制, 让两个线程连接在一起, 一个崩溃退出, 另一个也会收到相应的exit信号. 我们利用这个机制, 让所有的worker线程和supervisor线程连接在一起. 一个Supervisor管理一组Worker, 但Supervisor也需要被管理, 它们被更高层的Supervisor管理. 这样层层下来, 就形成supervisor tree

而这个pattern实在过于常用, 以至于erlang和elixir的library集合OTP中, 提供了相应的module和macro, 方便快速实现supervisor.
![[Think 2025-06-15 22.09.20.excalidraw]]

#### Name Service

另外一种应用pattern是name service.
actor model中使用pid作为线程的地址收发消息. 但是pid本身并不好记忆, 而且线程关闭重开后, pid都会发生变化. 给pid起一个稳定的别名, 能够让线程之间交互更加简单.
如果有一种机制, 能让别名映射pid, 我就只用记住别名, 需要pid的时候查询一下即可.

actor model中一般会把这种提供名字对pid映射的工作做成service, 供其他线程使用. 我们把这种服务称为Name service.
这个概念在网络服务中, 对应DNS服务器. 在分布式系统中, 对应zookeeper或者k8s中的service. 这是一种分布式系统中的常用服务.
这个概念本身很简单, 实现也不算特别难, 这里就不再提供代码示例.

#### Key-value Storage

还有一种分布式系统中的常用服务是key-value存储服务. 类似于redis, etcd这类的存在. 它可以方便在不同线程之间共享一些数据, 或者用来记录集群自身的状态和配置.
这里也不提供代码示例了. 有兴趣可以参考elixir in action这本书.

以上就是面向并发编程的全部内容了.
